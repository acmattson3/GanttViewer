<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Gantt Chart Viewer</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }
    /* Header controls */
    #header {
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }
    #header h1 {
      text-align: center;
      margin: 0 0 10px;
    }
    #header .controls {
      text-align: center;
      margin-bottom: 10px;
    }
    /* Scroll container */
    #tableContainer {
      overflow: auto;
      height: calc(100vh - 100px);
    }
    /* Unified table styling: enforce uniform cell height */
    #ganttTable {
      border-collapse: collapse;
      width: 100%;
    }
    #ganttTable th, #ganttTable td {
      border: 0px solid #ccc;
      text-align: center;
      font-size: 12px;
      padding: 4px;
      box-sizing: border-box;
      height: 20px; /* Fixed height for every cell */
    }
    /* Fixed width for metadata columns */
    .fixed {
      min-width: 80px;
      max-width: 80px;
      background: #fff;
    }
    /* Uniform day cells */
    .dayCell {
      min-width: 20px;
      max-width: 20px;
      width: 20px;
      height: 20px;
      line-height: 20px;
      padding: 0;
    }
    /* Shading for break days */
    .breakCell {
      background: #a4a4a4;
    }
    /* Red border for cells touching major dates */
    .majorDateCell {
      border-left: 2px solid red !important;
    }
    /* Task cell style */
    .taskBar {
      background: #1f77b4;
      color: #fff;
      border-radius: 3px;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
      height: 100%;
      line-height: 20px;
    }
    .important {
      font-weight: bold;
    }
    /* Sticky header rows */
    thead tr.weekGroup th {
      position: sticky;
      top: 0;
      background: #eee;
      z-index: 11;
      max-height: 34.67px;
      min-height: 34.67px;
    }
    thead tr.dayHeader th {
      position: sticky;
      top: 34.67px;
      /*top: var(--week-group-height);*/
      background: #ddd;
      z-index: 9;
      /*height: 20px;*/
    }
    /* Sticky left columns in header with higher z-index */
    thead .fixed:nth-child(1) { left: 0; z-index: 20; }
    thead .fixed:nth-child(2) { left: 80px; z-index: 20; }
    thead .fixed:nth-child(3) { left: 160px; z-index: 20; }
    thead .fixed:nth-child(4) { left: 240px; z-index: 20; }
    /* Sticky left columns in body */
    tbody .fixed {
      position: sticky;
      top: 0; /* they scroll vertically under the header */
      z-index: 1;
    }
    tbody .fixed:nth-child(1) { left: 0; }
    tbody .fixed:nth-child(2) { left: 80px; }
    tbody .fixed:nth-child(3) { left: 160px; }
    tbody .fixed:nth-child(4) { left: 240px; }
    /* Tooltip styling */
    #tooltip {
      position: absolute;
      background: #333;
      color: #fff;
      padding: 5px;
      border-radius: 3px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="header">
    <h1 id="chartTitle">Gantt Chart</h1>
    <div class="controls">
      Start Date: <input type="date" id="rangeStart">
      End Date: <input type="date" id="rangeEnd">
      <button id="applyRange">Apply</button>
      <input type="file" id="fileInput" accept=".json">
    </div>
  </div>
  <div id="tableContainer">
    <table id="ganttTable">
      <thead id="ganttThead">
        <!-- Header rows inserted dynamically -->
      </thead>
      <tbody id="ganttTbody">
        <!-- Task rows inserted dynamically -->
      </tbody>
    </table>
  </div>
  <div id="tooltip"></div>

  <script>
    // Constants and colors
    const DAY_WIDTH = 20;  // Uniform width for day cells
    const META_WIDTH = 80;
    const typeColors = ["#fb6262", "#ff9900", "#dada8a", "#6d9eeb"];
    let chartData = null;
    let visibleStart, visibleEnd;

    // Utility functions
    function parseDate(str) {
      const [year, month, day] = str.split("-").map(Number);
      return new Date(year, month - 1, day);
    }
    function formatDate(date) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, "0");
      const d = String(date.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }
    function daysBetween(start, end) {
      return Math.floor((end - start) / (1000 * 3600 * 24)) + 1;
    }
    function addDays(date, days) {
      const result = new Date(date);
      result.setDate(result.getDate() + days);
      return result;
    }
    function getMonday(date) {
      let d = new Date(date);
      let day = d.getDay();
      let diff = (day === 0 ? -6 : 1 - day);
      return addDays(d, diff);
    }
    // Overlap and break calculations
    function getOverlapDays(start1, end1, start2, end2) {
      const start = start1 > start2 ? start1 : start2;
      const end = end1 < end2 ? end1 : end2;
      if (start > end) return 0;
      return daysBetween(start, end);
    }
    function unionIntervals(intervals) {
      if (!intervals.length) return [];
      intervals.sort((a, b) => a[0] - b[0]);
      let res = [intervals[0]];
      for (let i = 1; i < intervals.length; i++) {
        let last = res[res.length - 1];
        if (intervals[i][0] <= last[1]) {
          last[1] = Math.max(last[1], intervals[i][1]);
        } else {
          res.push(intervals[i]);
        }
      }
      return res;
    }
    function calculateBreakOverlap(taskStart, taskEnd, breaks) {
      let intervals = [];
      breaks.forEach(b => {
        let bStart = parseDate(b.start_date);
        let bEnd = parseDate(b.end_date);
        let overlap = getOverlapDays(taskStart, taskEnd, bStart, bEnd);
        if (overlap > 0) {
          let start = Math.max(taskStart.getTime(), bStart.getTime());
          let end = Math.min(taskEnd.getTime(), bEnd.getTime());
          intervals.push([start, end]);
        }
      });
      intervals = unionIntervals(intervals);
      let total = 0;
      intervals.forEach(interval => {
        total += Math.floor((interval[1] - interval[0]) / (1000 * 3600 * 24)) + 1;
      });
      return total;
    }
    
    // Check if a given date is within any break period.
    function isBreakDay(date) {
      for (let b of chartData.breaks) {
        let bStart = parseDate(b.start_date);
        let bEnd = parseDate(b.end_date);
        if (date >= bStart && date <= bEnd) return true;
      }
      return false;
    }
    // Check if a given date matches a major date.
    function isMajorDate(date) {
      for (let md of chartData.major_dates) {
        let mdDate = parseDate(md.date);
        if (date.getFullYear() === mdDate.getFullYear() &&
            date.getMonth() === mdDate.getMonth() &&
            date.getDate() === mdDate.getDate()) {
          return true;
        }
      }
      return false;
    }
    // Return the major date's title (name) for the given date.
    function getMajorDateTitle(date) {
      for (let md of chartData.major_dates) {
        let mdDate = parseDate(md.date);
        if (date.getFullYear() === mdDate.getFullYear() &&
            date.getMonth() === mdDate.getMonth() &&
            date.getDate() === mdDate.getDate()) {
          return md.name;
        }
      }
      return "";
    }
    
    // Build an array of visible day strings from visibleStart to visibleEnd.
    function buildVisibleDays() {
      const total = daysBetween(visibleStart, visibleEnd);
      const days = [];
      for (let i = 0; i < total; i++) {
        days.push(formatDate(addDays(visibleStart, i)));
      }
      return days;
    }

    // Render the unified table with sticky headers, fixed left columns, and uniform cell dimensions.
    function renderTable() {
      if (!chartData) return;
      visibleStart = parseDate(document.getElementById("rangeStart").value);
      visibleEnd = parseDate(document.getElementById("rangeEnd").value);
      const visibleDays = buildVisibleDays();
      const totalDays = visibleDays.length;

      // Sort tasks by end date (soonest end date first)
      chartData.tasks.sort((a, b) => parseDate(a.end_date) - parseDate(b.end_date));

      // Build header
      const thead = document.getElementById("ganttThead");
      thead.innerHTML = "";

      // First header row: Week grouping.
      let trWeek = document.createElement("tr");
      trWeek.className = "weekGroup";
      // First 4 fixed columns (blank)
      for (let i = 0; i < 4; i++) {
        let th = document.createElement("th");
        th.className = "fixed";
        th.style.minWidth = META_WIDTH + "px";
        th.style.width = META_WIDTH + "px";
        th.textContent = "";
        trWeek.appendChild(th);
      }
      // Group visible days by week (each group shows the Monday date)
      let i = 0;
      while (i < totalDays) {
        let currentDay = parseDate(visibleDays[i]);
        let monday = getMonday(currentDay);
        let groupCount = 0;
        while (i + groupCount < totalDays) {
          let d = parseDate(visibleDays[i + groupCount]);
          if (getMonday(d).getTime() === monday.getTime()) {
            groupCount++;
          } else {
            break;
          }
        }
        let th = document.createElement("th");
        th.colSpan = groupCount;
        th.style.minWidth = (groupCount * DAY_WIDTH) + "px";
        th.style.width = (groupCount * DAY_WIDTH) + "px";
        th.style.height = "34.67px";
        th.textContent = formatDate(monday);
        trWeek.appendChild(th);
        i += groupCount;
      }
      thead.appendChild(trWeek);

      // Second header row: one cell per visible day, preceded by metadata headers.
      let trDay = document.createElement("tr");
      trDay.className = "dayHeader";
      const headers = ["Tasks", "Start", "End", "Days"];
      for (let j = 0; j < 4; j++) {
        let th = document.createElement("th");
        th.textContent = headers[j];
        th.className = "fixed";
        th.style.minWidth = META_WIDTH + "px";
        th.style.width = META_WIDTH + "px";
        // Set sticky left positions for header fixed cells
        if (j === 0) th.style.left = "0px";
        if (j === 1) th.style.left = META_WIDTH + "px";
        if (j === 2) th.style.left = (META_WIDTH * 2) + "px";
        if (j === 3) th.style.left = (META_WIDTH * 3) + "px";
        trDay.appendChild(th);
      }
      // Create one header cell per visible day.
      visibleDays.forEach((dayStr, index) => {
        let th = document.createElement("th");
        th.className = "dayCell";
        th.style.minWidth = DAY_WIDTH + "px";
        th.style.width = DAY_WIDTH + "px";
        let cellDate = addDays(visibleStart, index);
        if (isBreakDay(cellDate)) th.classList.add("breakCell");
        if (isMajorDate(cellDate)) {
          th.classList.add("majorDateCell");
          th.style.zIndex = "10";
          // Set the major date title in the cell.
          th.textContent = getMajorDateTitle(cellDate);
        } else {
          th.textContent = ""; // No label if not a major date.
        }
        trDay.appendChild(th);
      });
      thead.appendChild(trDay);

      // Build table body with one row per task.
      const tbody = document.getElementById("ganttTbody");
      tbody.innerHTML = "";
      chartData.tasks.forEach(task => {
        let taskStart = parseDate(task.start_date);
        let taskEnd = parseDate(task.end_date);
        if (taskEnd < visibleStart || taskStart > visibleEnd) return;

        let tr = document.createElement("tr");

        // Fixed metadata cells (sticky left)
        let tdName = document.createElement("td");
        tdName.textContent = task.name;
        tdName.className = "fixed";
        tdName.style.minWidth = META_WIDTH + "px";
        tdName.style.width = META_WIDTH + "px";
        tdName.style.position = "sticky";
        tdName.style.left = "0px";
        if (task.important) {
          tdName.classList.add("important");
        }
        tr.appendChild(tdName);

        let tdStart = document.createElement("td");
        tdStart.textContent = task.start_date;
        tdStart.className = "fixed";
        tdStart.style.minWidth = META_WIDTH + "px";
        tdStart.style.width = META_WIDTH + "px";
        tdStart.style.position = "sticky";
        tdStart.style.left = META_WIDTH + "px";
        tr.appendChild(tdStart);

        let tdEnd = document.createElement("td");
        tdEnd.textContent = task.end_date;
        tdEnd.className = "fixed";
        tdEnd.style.minWidth = META_WIDTH + "px";
        tdEnd.style.width = META_WIDTH + "px";
        tdEnd.style.position = "sticky";
        tdEnd.style.left = (META_WIDTH * 2) + "px";
        tr.appendChild(tdEnd);

        let totalTaskDays = daysBetween(taskStart, taskEnd);
        let breakDays = calculateBreakOverlap(taskStart, taskEnd, chartData.breaks);
        let activeDays = totalTaskDays - breakDays;
        let tdDays = document.createElement("td");
        tdDays.textContent = totalTaskDays + (breakDays > 0 ? " (" + activeDays + ")" : "");
        tdDays.className = "fixed";
        tdDays.style.minWidth = META_WIDTH + "px";
        tdDays.style.width = META_WIDTH + "px";
        tdDays.style.position = "sticky";
        tdDays.style.left = (META_WIDTH * 3) + "px";
        tr.appendChild(tdDays);

        // Build day cells for the task row.
        let activeStart = taskStart < visibleStart ? visibleStart : taskStart;
        let activeEnd = taskEnd > visibleEnd ? visibleEnd : taskEnd;
        let startIndex = daysBetween(visibleStart, activeStart) - 1;
        let duration = daysBetween(activeStart, activeEnd);
        // Add empty cells before the task.
        for (let i = 0; i < startIndex; i++) {
          let td = document.createElement("td");
          td.className = "dayCell";
          td.style.minWidth = DAY_WIDTH + "px";
          td.style.width = DAY_WIDTH + "px";
          let cellDate = addDays(visibleStart, i);
          if (isBreakDay(cellDate)) td.classList.add("breakCell");
          if (isMajorDate(cellDate)) td.classList.add("majorDateCell");
          tr.appendChild(td);
        }
        // Task cell spanning the active days.
        let tdTask = document.createElement("td");
        tdTask.className = "dayCell taskBar";
        tdTask.colSpan = duration;
        tdTask.style.minWidth = (DAY_WIDTH * duration) + "px";
        tdTask.style.width = (DAY_WIDTH * duration) + "px";
        let color = typeColors[task.type % typeColors.length];
        tdTask.style.background = color;
        tdTask.style.color = "#fff";
        tdTask.textContent = task.name;
        if (task.important) {
          tdTask.classList.add("important");
        }
        tdTask.addEventListener("mouseover", (e) => {
          let tooltip = document.getElementById("tooltip");
          tooltip.innerHTML = `<strong>${task.name}</strong><br>
                               Start: ${task.start_date}<br>
                               End: ${task.end_date}<br>
                               Type: ${chartData.types[task.type]}<br>
                               High Priority: ${task.important ? "Yes" : "No"}<br>
                               Days: ${totalTaskDays}${breakDays > 0 ? " (" + activeDays + ")" : ""}`;
          tooltip.style.opacity = 1;
        });
        tdTask.addEventListener("mousemove", (e) => {
          let tooltip = document.getElementById("tooltip");
          tooltip.style.left = (e.pageX + 10) + "px";
          tooltip.style.top = (e.pageY + 10) + "px";
        });
        tdTask.addEventListener("mouseout", () => {
          let tooltip = document.getElementById("tooltip");
          tooltip.style.opacity = 0;
        });
        tr.appendChild(tdTask);
        // Add empty cells after the task.
        let added = startIndex + duration;
        for (let i = added; i < totalDays; i++) {
          let td = document.createElement("td");
          td.className = "dayCell";
          td.style.minWidth = DAY_WIDTH + "px";
          td.style.width = DAY_WIDTH + "px";
          let cellDate = addDays(visibleStart, i);
          if (isBreakDay(cellDate)) td.classList.add("breakCell");
          if (isMajorDate(cellDate)) td.classList.add("majorDateCell");
          tr.appendChild(td);
        }

        tbody.appendChild(tr);
      });
    }

    // File input: load JSON and initialize date range.
    document.getElementById("fileInput").addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          chartData = JSON.parse(event.target.result);
          document.getElementById("chartTitle").textContent = chartData.title;
          document.getElementById("rangeStart").value = chartData.global_start_date;
          document.getElementById("rangeEnd").value = chartData.global_end_date;
          renderTable();
        } catch (error) {
          alert("Error parsing JSON: " + error);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById("applyRange").addEventListener("click", function() {
      if (!document.getElementById("rangeStart").value || !document.getElementById("rangeEnd").value) {
        alert("Please select both start and end dates.");
        return;
      }
      renderTable();
    });

    window.addEventListener("load", () => {
      fetch("lunabotics-2026-chart.json")
        .then(response => {
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          return response.json();
        })
        .then(data => {
          chartData = data;
          document.getElementById("chartTitle").textContent = chartData.title;
          document.getElementById("rangeStart").value = chartData.global_start_date;
          document.getElementById("rangeEnd").value = chartData.global_end_date;
          renderTable();
        })
        .catch(error => console.error("Error loading default JSON file:", error));
    });
  </script>
</body>
</html>
